import json
import os
import cv2
import time

from detector import detect_objects, map_yolo_class
from pathfinding import move_robot_toward_multiple_targets


class MissionCommander:
    def __init__(self):
        self.goal_file = 'control_goal.json'

        self.map_image_path = "scan_result.jpg"
        self.meters_per_pixel = 0.12 # base on parameter in SLAM.py

    def analyze_scene_and_plan(self):
        """
        Call perception module (detector) and path planning module (pathfinding)
        Generate actual rescue path
        """
        if not os.path.exists(self.map_image_path):
            print(f"Cannot find map image {self.map_image_path}")
            return []

        print(f"Analyzing disaster area image...")

        # 1. Read image (logic from SLAM.py)
        img_bgr = cv2.imread(self.map_image_path)
        img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)

        # 2. Detect objects (using detector.py)
        result = detect_objects(img_rgb)

        persons = []
        print(f" {len(result.boxes)} objects detected.")

        # 3. Extract survivor coordinates (logic from SLAM.py)
        for box in result.boxes:
            name = result.names[int(box.cls)]
            mapped_class = map_yolo_class(name)

            if mapped_class == "person":
                x1, y1, x2, y2 = map(int, box.xyxy[0])
                # Calculate center point and convert in physical coordinate system
                cx = (x1 + x2) / 2 * self.meters_per_pixel
                cy = (y1 + y2) / 2 * self.meters_per_pixel
                persons.append((cx, cy))
                print(f"find survivor at ({cx:.2f}meters, {cy:.2f}meters)")

        if not persons:
            print("No survivors were found. The mission is cancelled or the default hover is executed")
            return []

        # 4. Path planning (using pathfinding.py)
        start_pos = (0, 0)
        print(f"ðŸ—ºï¸ Planning path: starting point {start_pos} -> {len(persons)} objects.")

        # Get a series of dense path points [(x,y), (x,y)...]
        raw_path = move_robot_toward_multiple_targets(start_pos, persons, step_size=0.5)

        # 5. Format to JSON format that teammate controller can understand
        formatted_waypoints = []
        flight_height = 1.2  # Set flight height

        # convert 2D points generated by pathfinding to 3D waypoints
        for p in raw_path:
            formatted_waypoints.append({
                "position": [float(p[0]), float(p[1]), flight_height],
                "altitude": flight_height
            })

        return formatted_waypoints

    def dispatch_mission(self, waypoints):
        if not waypoints:
            return

        mission_data = {
            "timestamp": time.time(),
            "mission_id": "RESCUE_PATH_V1",
            "waypoints": waypoints
        }

        try:
            with open(self.goal_file, 'w', encoding='utf-8') as f:
                json.dump(mission_data, f, indent=4)
            print(f"mission dispatched; contain {len(waypoints)} waypoints")
            print(f"press 'G' to start executing")
        except Exception as e:
            print(f"dispatch failed - {e}")


if __name__ == "__main__":
    commander = MissionCommander()
    path = commander.analyze_scene_and_plan()
    commander.dispatch_mission(path)