import json
import os
import cv2
import time
import math

from detector import detect_objects, map_yolo_class
from pathfinding import move_robot_toward_multiple_targets


class MissionCommander:
    def __init__(self):
        self.goal_file = 'control_goal.json'

        self.map_image_path = "scan_result.jpg"
        self.meters_per_pixel = 0.12 # base on parameter in SLAM.py

        # mark same survivors
        self.known_survivors = []
        self.duplicate_threshold = 1.0
        self.survivors_file = "found_survivors.json"
        if os.path.exists(self.survivors_file):
            with open(self.survivors_file, 'r') as f:
                self.known_survivors = json.load(f)
        else:
            self.known_survivors = []

    def analyze_scene_and_plan(self):
        """
        Call perception module (detector) and path planning module (pathfinding)
        Generate actual rescue path
        """
        if not os.path.exists(self.map_image_path):
            print(f"Cannot find map image {self.map_image_path}")
            return []

        print(f"Analyzing disaster area image...")

        # Read image (logic from SLAM.py)
        img_bgr = cv2.imread(self.map_image_path)
        img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB)

        # Analysis coordinate
        img_h, img_w, _ = img_rgb.shape
        camera_fov = 0.84
        drone_altitude = 1.75
        visible_width = 2 * drone_altitude * math.tan(camera_fov / 2)
        self.meters_per_pixel = visible_width / img_w
        print(f"[Analysis] Dynamic Scale: {self.meters_per_pixel:.5f} m/px (Alt: {drone_altitude}m)")

        # Detect objects (using detector.py)
        result = detect_objects(img_rgb)

        persons = []
        current_detections = []
        print(f" {len(result.boxes)} objects detected.")

        # Extract survivor coordinates (logic from SLAM.py)
        for box in result.boxes:
            name = result.names[int(box.cls)]
            mapped_class = map_yolo_class(name)

            img_h, img_w, _ = img_rgb.shape
            center_x = img_w / 2
            center_y = img_h / 2

            if mapped_class == "person":
                x1, y1, x2, y2 = map(int, box.xyxy[0])
                # Calculate center point and convert in physical coordinate system
                px = (x1 + x2) / 2
                py = (y1 + y2) / 2
                offset_x_px = px - center_x
                offset_y_px = center_y - py

                # Oblique View Correction
                camera_tilt = 0.785
                center_dist_x = drone_altitude * math.tan(camera_tilt)
                cx = center_dist_x + (offset_y_px * self.meters_per_pixel)
                cy = -(offset_x_px * self.meters_per_pixel)

                # cx = offset_x_px * self.meters_per_pixel
                # cy = offset_y_px * self.meters_per_pixel

                is_new_target = True
                for existing_survivor in self.known_survivors:
                    dist = math.hypot(cx - existing_survivor[0], cy - existing_survivor[1])
                    if dist < self.duplicate_threshold:
                        is_new_target = False
                        print(f"Duplicate target ignored (dist={dist:.2f}m)")
                        break

                if is_new_target:
                    self.known_survivors.append((cx, cy))
                    current_detections.append((cx, cy))
                    print(f"New survivor confirmed at ({cx:.2f}, {cy:.2f})")

                persons.append((cx, cy))
                print(f"Find survivor at ({cx:.2f}meters, {cy:.2f}meters)")

        if not persons:
            print("No survivors were found.")
            return []

        # Path planning (using pathfinding.py)
        start_pos = (0, 0)
        print(f"Planning path: starting point {start_pos} -> {len(persons)} objects.")

        # Get a series of dense path points [(x,y), (x,y)...]
        raw_path = move_robot_toward_multiple_targets(start_pos, persons, step_size=0.5)

        # Format to JSON format that teammate controller can understand
        formatted_waypoints = []
        flight_height = 1.2  # Set flight height

        # Convert 2D points generated by pathfinding to 3D waypoints
        for p in raw_path:
            formatted_waypoints.append({
                "position": [float(p[0]), float(p[1]), flight_height],
                "altitude": flight_height
            })

        with open(self.survivors_file, 'w') as f:
           json.dump(self.known_survivors, f)

        return formatted_waypoints

    def dispatch_mission(self, waypoints):
        if waypoints is None:
            waypoints = []

        mission_data = {
            "timestamp": time.time(),
            "mission_id": "RESCUE_PATH_V1",
            "waypoints": waypoints
        }

        try:
            with open(self.goal_file, 'w', encoding='utf-8') as f:
                json.dump(mission_data, f, indent=4)

            if not waypoints:
                print(f"Mission dispatched: NO TARGETS")
            else:
                print(f"mission dispatched; contain {len(waypoints)} waypoints")

        except Exception as e:
            print(f"dispatch failed - {e}")


if __name__ == "__main__":
    commander = MissionCommander()
    path = commander.analyze_scene_and_plan()
    commander.dispatch_mission(path)